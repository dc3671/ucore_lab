# Lab5 report #

[TOC]

## 练习1 ##

[练习1.1]请在实验报告中简要说明你的设计实现过程。

- 按照注释提示，设置子进程的trapframe的一系列初始值，包括各个段寄存器的初始化，还有初始化进程使用的栈结构以及起始地址等上下文结构。
- 将cs设置为用户代码段`USER_CS`，ds,es,ss均设为用户数据段`USER_DS`。esp设为用户栈的顶端USTACKTOP（=用户空间的顶端USERTOP=0xB0000000），eip为传入参数程序的入口地址，eflags寄存器中打开中断位即可。

[练习1.2]请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

- 与lab4中initproc跳转到`init_main()`的过程类似，首先在新建外壳`kernel_thread()`时会把由`init_main()`传入的参数`user_main()`赋值给新线程的eip，完成`do_fork()`等一系列操作返回之后，在`init_main()`里会运行`schedule()`，类似initproc的运行流程，切换上下文、中断帧，由iret结束中断状态开始运行（即RUNNING态），接着会调用中断帧保存的状态，即`kernel_thread_entry`，然后`call *%ebx`，于是进入`user_main()`。
- 在`user_main()`里会运行`KERNEL_EXECVE2`执行脚本中给定的TEST系统调用，在系统调用过程中，通过`sys_call()``sys_exec``do_execve`进入`load_icode`，在这便将内核线程转换成了一个用户进程，在中断帧里设置`tf->tf_eip = elf->e_entry;`于是在中断返回之后，便会跳入指定的代码程序进行运行。

## 练习2 ##

[练习2.1]请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。

- 在父进程fork子进程时，可以将子进程的cr3寄存器设为与自己相同，即两者暂时使用相同的内存空间，同时将自己拥有的页表项`PTE_W`都设为0即只读，这样子进程可以完整地读父进程地内存内容。而当子进程试图修改页面进行写操作时，会引发page fault异常，此时在中断服务例程中检查是否是copy on write的情况，于是便可以调用`copy_range()`函数拷贝对应的页面到一个新的内存空间让进程完成写操作。
- 这样便达到了加速进程复制、减少内存占用且子进程仍可以按照需要修改自己的页面的效果。

## 练习3 ##

[练习3.1]请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？

- `do_fork`中会对进程进行初始化，然后调用wakup_proc函数将进程状态设置为RUNNABLE等待分配时间片。
- `do_execve`中没有修改进程的状态，仅仅拷贝了可执行二进制代码。
- `do_wait`中会对进程的子进程进行检测，如果其子进程都已经结束或都是僵尸进程，则直接结束这个进程释放资源。如果其子进程还没有结束，则将其置于SLEEPING状态。
- `do_exit`中会释放一个进程所占用的资源，将其变为ZOMBIE状态，然后判断其父进程是否处于等待状态（`WT_CHILD`），如果是则调用`wakeup_proc`唤醒父进程。若此进程含有子进程，则将子进程交由内核线程initproc处理。
- `do_kill`中会直接唤醒进程并将其eflags中的PF_EXITING位置1，强制进程退出。

[练习3.2]请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

```
-                                                      PROC_ZOMBIE <-------------------------
-                                                        ^                                  |
-                                                        |                                  | 
-                                                        |                                  |
-                                                        |                                  |
-                                                        | do_exit                          | do_exit
-                                                        |                                  |
-                                                        |                                  |
-                                                        |                                  |
-   alloc_proc                   do_fork/wakeup_proc     |                 do_wait          |
-----------------> PROC_UNINIT ----------------------> PROC_RUNNABLE -----------------> PROC_SLEEPING
-                                                        |           <-----------------
-                                                        |                 do_exit  
-                                                        |
-                                                        |
-                                                        |
-                                                        | do_wait
-                                                        |
-                                                        |
-                                                        |
-                                                       \ /
-                                                     (freed)
```

## 与参考答案的不同 ##

- 在根据注释完成相应代码填写之后，运行`make grade`发现仍有错误，在与答案进行对照之后，发现时钟中断的输出函数`print_ticks()`在答案中没有出现！这导致我的部分结果是错误的。
- 在仔细对比了答案之后，才发现这里是问题的源头。

## 重要知识点 ##

- 主要知识点是如何由内核线程initproc通过`user_main`进行系统调用进而依着`sys_call()``sys_exec``do_execve`这一条线进入`load_icode`，最终执行用户代码程序。由于对lab4中initproc的创建、启动过程比较熟悉，所以lab5也完成得比较轻松，且能够很好地理解用户态进程的各种执行状态以及切换关系，之前的段机制、特权级描述也都在切换用户态中起到了作用。
- 原理课中提到了进程PCB的组织方式队列，在实验中没有很好地体现。且对于进程调度的方式也没有讲解，只是给出了代码，在实现上没有要求。
