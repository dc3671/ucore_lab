# Lab2 report #

[TOC]

## 练习1 ##

[练习1.1]请在实验报告中简要说明你的设计实现过程。

- 首先阅读实验指导的gitbook之后，了解到此次实验主要涉及的两个结构：vma和mm。
- vma是一块合法的虚拟内存空间，表明曾经用户请求过该虚拟地址的内存空间。不同vma之间互不相交，共同由一个mm结构进行管理，同一个mm结构下的虚拟内存空间属于同一个页目录表项下。
- mm是管理同一个页目录表项下虚拟内存空间块的结构，也保存了该页目录表项的基址`pgdir`，所以可以与线性地址一起用来得到地址对应的页表项。
- 实际代码中，用get_pte()、mm中保存的基址、CR2中保存的请求的地址得到对应页表项，进而可以得到其对应的物理地址，当不存在时做相应的处理。

**与参考答案的不同:**

- 一开始我传给`get_pte`、`pgdir_alloc_page`的第二个参数用的是`vma->vm_start`，但是实际上一个vma包含的并不只是一页，所以用来请求页表时并不能这样写，尽管请求的地址确实是在vma内的。

[练习1.2]请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。

- 页表项中的`PTE_P`、`PTE_W`、`PTE_U`这些标志位可以用来识别触发缺页异常的类型，是越权访问还是缺页，是分配算法的前期判断，而且也是分配好页面后修改页面属性的依据。
- `PTE_A`与`PTE_D`位则可以用来记录是否被访问过、是否被改写过，可以用于选择换出的页。

[练习1.3]如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

- 再次触发缺页异常，将现场保存，进入double fault处理例程。

## 练习2 ##

[练习2.1]请在实验报告中简要说明你的设计实现过程。

- 由实验指导书大概了解swap的几个方法，在`do_pgfault`函数中当所请求的物理页已经被换出到硬盘中时，调用`swap_in`、`page_insert`、`swap_map_swappable`将请求的页面从硬盘读取到内存中。
- 对于fifo的置换算法，当新加入的页面添到队列的结尾，用`list_add`方法；当需要置换出页面给新的页面时，置换最开头的页面，将其从队列中删除，用`list_del`方法。

**与参考答案的不同:**

- 基本上没有差别，我是更加符合逻辑地把列表头认为是`head`之后紧跟的链表项，插入的页插在`head`之前作为尾部，答案则相反。而且答案的assert更加细致。

[练习2.2]如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题：
    需要被换出的页的特征是什么？
    在ucore中如何判断具有这样特征的页？
    何时进行换入和换出操作？

- 已有框架可以实现扩展时钟算法，由于页表项中有`PTE_A`与`PTE_D`位，可以获知页是否访问过是否被修改过，所以满足扩展时钟算法需要两个标志位的要求。需要解决的问题是在swap_manager中访问这个标志位，即取得实际页面与页表项的对应关系，同时可以修改这个标志位。
- 特征是位于指针依次访问中最先遇到的未被访问且未被修改的页（考虑到如果被访问过，则在指针扫过之后会被标记为未被访问，以及修改页会写回并标记未修改。）
- 利用pra_list环形链表的遍历，辨识当前页的两个标志位。
- ucore采用的是消极替换策略，故换入换出的时机总是在缺页时。

## 重要知识点 ##

- 本次实验一中，`do_pgfault`函数前半部分对于页缺失异常的处理流程表现的非常详细，很好地说明了如何判断一个页访问异常是缺页异常，及哪些应该判断为非法、哪些应该分配页面。
- 实验二则简单地明确了一遍页置换算法应该是怎样一个流程。
- 没有涉及到的包括全局置换算法、缺失率置换算法，这也是由于lab3中还未涉及多进程的缘故。
